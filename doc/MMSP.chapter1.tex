% MMSP.chapter1.tex

\chapter{Introduction}
The goal of the Mesoscale Microstructure Simulation Project ({\tt MMSP}) is to provide a simple, consistent, and extensible programming interface for all grid and mesh based microstructure evolution methods. Simple means that the package has a very small learning curve, and for most routine simulations, only a minimal amount of code must be written. By consistent we mean, for example, that code for two-dimensional simulations is nearly identical to that for three-dimensional simulations, single processor programs are easily parallelized, and fundamentally different methods like Monte Carlo or phase field have the same look and feel. Finally, extensible means that it's straightforward to add new grid types or physical behaviors to the package. Other considerations include efficiency and portability ({\tt MMSP} is written entirely in ISO compliant {\tt c++}).

\section{The {\tt MMSP} concept}
The design of {\tt MMSP} is based on several observations about how mesoscale simulations are used by materials scientists: most mesoscale simulations discretize the spatial domain using a rectilinear grid. A data structure is associated with each grid node that has a particular size (scalar, vector, etc.) and value type (integer, floating point) depending on the simulation method. Most simulations update the data structure at each node in a way that falls under some common methodology (Monte Carlo, phase field, etc.) but has features unique to each given physical process.  What this roughly means is that most mesoscale simulations use a common spatial discretization, but we usually need to tweak the details of how we represent spatial data and how we update it. The unfortunate truth is that typically, a researcher wishing to model a particular physical process produces code with a focus mainly on the particulars of the process itself (the ``tweak''), largely ignoring the problem of how to design reusable data structures. What happens when they decide they should try a different simulation method, or when they realize that they need to use a parallel implementation?  It then becomes apparent that more flexible data structures should have been used in the first place.  The purpose of {\tt MMSP} is to provide the core functionality that we don't necessarily want to think about each time we program a new method.  {\tt MMSP} helps keep its users from reinventing grid data structures, file input and output, parallelization, handling boundary conditions, etc.\ while retaining enough flexibility to model a large number of physical processes.

Those familiar with similar code packages might have already noticed that the {\tt MMSP} concept is a bit unusual. Other packages typically provide a very high level interface intended for use with a {\em single} computational method.  Using the interface typically means learning package-specific methodology, classes, functions, methods, etc.  In contrast, {\tt MMSP} is meant to be used for any and all grid-based methods, and provides a much lower level interface.  This results in a lot more flexibility in what {\tt MMSP} can do.  And while {\tt MMSP} still requires some learning, users will find that they are able to leverage much more of their previous programming experience.

\section{What {\tt MMSP} does}
{\tt MMSP} is nothing more than a collection of {\tt c++} header files that declare a number of {\tt grid} objects (classes) and define how most of their methods (member functions) are implemented.  Some things {\tt MMSP} provides include:
\begin{itemize}
\item A simple, extensible programming interface
\item Computational grids of arbitrary dimension
\item Parallel implementations using MPI
\item Automatic, optimal parallel mesh topologies
\item Utility programs for grid visualization
\item Classes for Monte Carlo methods
\item Classes for cellular automata methods 
\item Classes for phase field methods (conventional)
\item Classes for phase field methods (sparsePF)
\item Classes for general finite difference PDE solvers
\item Example simulation methods and grid objects
\end{itemize}

\section{What {\tt MMSP} doesn't do}
{\tt MMSP} is not the kind of software that reads a few parameters or an input file specified by the user and cranks out some generic computation. In fact, {\tt MMSP} relies on the user to provide code for all of the real physics that the simulation is intended to capture. This isn't as scary as it sounds. {\tt MMSP} was designed to make this procedure as simple as possible. The takeaway message here is that {\tt MMSP} makes programming materials simulation code easier, but it isn't a ``black box'' that can be used by a complete novice.

\section{What {\tt MMSP} requires}
The {\tt MMSP} interface is intended to look and feel very natural for most programmers with experience in scientific computing.  While many of the most advanced features of {\tt c++} have been used in creating the grid and data classes, the user need not be proficient in anything other than basic procedural programming.  {\tt Fortran}, {\tt c}, and novice {\tt c++} programmers alike will find that {\tt MMSP} is quite easy to use.  Basic requirements include:
\begin{itemize}
\item Minimal programming experience
\item A {\tt c++} compiler with ISO compliant libraries and headers (e.g. {\tt gcc} 2.95 or later)
\item MPI libraries are required if compiling parallel programs (e.g. OpenMPI)
\end{itemize}

\section{Terms of use}
{\tt MMSP} is freely available for anyone performing non--profit scientific research; those interested in using {\tt MMSP} for any other purposes should contact the author. We give no guarantees whatsoever about the capabilities of {\tt MMSP}. If you use {\tt MMSP} in your research, please tell others about it, send us any new code you'd like to see incorporated into the package, and above all, give us feedback! 

